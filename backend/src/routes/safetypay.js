const express = require('express');
const router = express.Router();
const axios = require('axios');
const crypto = require('crypto');

// Configuraci√≥n de SafetyPay
const SAFETYPAY_CONFIG = {
  apiKey: process.env.SAFETYPAY_API_KEY,
  signatureKey: process.env.SAFETYPAY_SIGNATURE_KEY,
  apiUrl: process.env.SAFETYPAY_API_URL || 'https://sandbox.safetypay.com/express2',
  isProduction: process.env.NODE_ENV === 'production'
};

// Generar firma
function generateSignature(data, key) {
  return crypto.createHmac('sha256', key).update(data).digest('hex');
}

// POST /api/safetypay/create-transaction - Crear transacci√≥n
router.post('/create-transaction', async (req, res) => {
  try {
    const { orderId, amount, email, firstName, lastName } = req.body;

    console.log('üè¶ Creando transacci√≥n SafetyPay:', { orderId, amount, email });

    if (!orderId || !amount || !email) {
      return res.status(400).json({
        success: false,
        message: 'orderId, amount y email son requeridos'
      });
    }

    if (!SAFETYPAY_CONFIG.apiKey || !SAFETYPAY_CONFIG.signatureKey) {
      return res.status(400).json({
        success: false,
        message: 'SafetyPay no est√° configurado en el servidor'
      });
    }

    // Datos de la transacci√≥n
    const transactionData = {
      ApiKey: SAFETYPAY_CONFIG.apiKey,
      RequestDateTime: new Date().toISOString(),
      MerchantSalesID: orderId,
      Language: 'ES',
      TrackingCode: orderId,
      Amount: parseFloat(amount).toFixed(2),
      CurrencyID: '604', // 604 = PEN
      PaymentCountryCode: 'PE',
      TransactionOkURL: `${process.env.FRONTEND_URL}/payment/success`,
      TransactionErrorURL: `${process.env.FRONTEND_URL}/payment/error`,
      TransactionExpirationDateTime: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(), // 48 horas
      ProductID: '1', // 1 = Online Banking
      CustomMerchantValue: JSON.stringify({
        email,
        firstName,
        lastName
      })
    };

    // Generar firma
    const signatureString = `${transactionData.ApiKey}${transactionData.RequestDateTime}${transactionData.MerchantSalesID}${transactionData.Amount}${transactionData.CurrencyID}`;
    const signature = generateSignature(signatureString, SAFETYPAY_CONFIG.signatureKey);

    transactionData.Signature = signature;

    // Hacer request a SafetyPay
    const response = await axios.post(
      `${SAFETYPAY_CONFIG.apiUrl}/NewOperation2`,
      transactionData,
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );

    const result = response.data;

    console.log('‚úÖ Transacci√≥n SafetyPay creada:', result.TransactionIdentifier);

    res.status(200).json({
      success: true,
      transactionId: result.TransactionIdentifier,
      redirectUrl: result.ClientRedirectURL,
      expirationDate: result.ExpirationDateTime,
      instructions: {
        title: 'C√≥mo pagar con SafetyPay',
        steps: [
          '1. Ser√°s redirigido a tu banco',
          '2. Inicia sesi√≥n en tu banca online',
          '3. Confirma la transferencia',
          '4. Recibir√°s confirmaci√≥n inmediata',
          '5. Tu compra ser√° procesada autom√°ticamente'
        ],
        supportedBanks: 'BCP, Interbank, BBVA, Scotiabank y m√°s'
      }
    });

  } catch (error) {
    console.error('‚ùå Error al crear transacci√≥n SafetyPay:', error.response?.data || error.message);

    res.status(500).json({
      success: false,
      message: 'Error al crear transacci√≥n',
      error: process.env.NODE_ENV === 'development' ? (error.response?.data || error.message) : undefined
    });
  }
});

// POST /api/safetypay/verify - Verificar estado de transacci√≥n
router.post('/verify', async (req, res) => {
  try {
    const { transactionId, orderId } = req.body;

    console.log('üîç Verificando transacci√≥n SafetyPay:', { transactionId, orderId });

    if (!transactionId && !orderId) {
      return res.status(400).json({
        success: false,
        message: 'transactionId u orderId requerido'
      });
    }

    if (!SAFETYPAY_CONFIG.apiKey || !SAFETYPAY_CONFIG.signatureKey) {
      return res.status(400).json({
        success: false,
        message: 'SafetyPay no est√° configurado'
      });
    }

    // Datos de consulta
    const queryData = {
      ApiKey: SAFETYPAY_CONFIG.apiKey,
      RequestDateTime: new Date().toISOString(),
      MerchantSalesID: orderId,
      TransactionIdentifier: transactionId
    };

    // Generar firma
    const signatureString = `${queryData.ApiKey}${queryData.RequestDateTime}${queryData.MerchantSalesID || ''}${queryData.TransactionIdentifier || ''}`;
    const signature = generateSignature(signatureString, SAFETYPAY_CONFIG.signatureKey);

    queryData.Signature = signature;

    // Consultar estado
    const response = await axios.post(
      `${SAFETYPAY_CONFIG.apiUrl}/OperationActivity`,
      queryData,
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );

    const result = response.data;

    console.log('‚úÖ Estado de transacci√≥n:', result.OperationStatus);

    res.status(200).json({
      success: true,
      status: result.OperationStatus, // PENDING, PAID, CANCELLED
      transactionId: result.TransactionIdentifier,
      orderId: result.MerchantSalesID,
      amount: result.Amount,
      paymentDate: result.ConfirmationDateTime,
      isPaid: result.OperationStatus === 102 // 102 = PAID
    });

  } catch (error) {
    console.error('‚ùå Error al verificar transacci√≥n:', error.response?.data || error.message);

    res.status(500).json({
      success: false,
      message: 'Error al verificar transacci√≥n',
      error: process.env.NODE_ENV === 'development' ? (error.response?.data || error.message) : undefined
    });
  }
});

// POST /api/safetypay/webhook - Webhook para notificaciones
router.post('/webhook', async (req, res) => {
  try {
    const notification = req.body;

    console.log('üì¨ Webhook SafetyPay recibido:', notification);

    // Validar firma
    const receivedSignature = notification.Signature;
    const signatureString = `${notification.ApiKey}${notification.RequestDateTime}${notification.MerchantSalesID}${notification.ReferenceNo}`;
    const calculatedSignature = generateSignature(signatureString, SAFETYPAY_CONFIG.signatureKey);

    if (receivedSignature !== calculatedSignature) {
      console.warn('‚ö†Ô∏è  Firma del webhook inv√°lida');
      return res.status(403).json({
        success: false,
        message: 'Firma inv√°lida'
      });
    }

    // Procesar notificaci√≥n
    const { MerchantSalesID, OperationStatus, Amount, TransactionIdentifier } = notification;

    if (OperationStatus === 102) { // 102 = PAID
      console.log(`‚úÖ Pago confirmado para orden ${MerchantSalesID}`);

      // Actualizar estado de la orden en la base de datos
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      try {
        const order = await prisma.order.findUnique({
          where: { id: MerchantSalesID },
          include: { items: true }
        });

        if (order) {
          await prisma.order.update({
            where: { id: MerchantSalesID },
            data: {
              paymentStatus: 'PAID',
              status: 'CONFIRMED',
              notes: `Pago confirmado v√≠a SafetyPay. Transaction ID: ${TransactionIdentifier}, Monto: S/ ${Amount}`
            }
          });

          console.log(`‚úÖ Orden ${order.orderNumber} actualizada a PAID`);

          // Crear √≥rdenes con proveedores y enviar notificaciones
          setTimeout(async () => {
            try {
              const { createSupplierOrderFromCustomerOrder } = require('../services/supplierOrderService');
              const { sendOrderToSuppliers } = require('../services/supplierNotificationService');
              const whatsappService = require('../services/whatsappService');

              const supplierResult = await createSupplierOrderFromCustomerOrder(MerchantSalesID);

              if (supplierResult.success) {
                console.log(`‚úÖ ${supplierResult.supplierOrders.length} √≥rdenes con proveedores creadas`);
                await sendOrderToSuppliers(supplierResult.supplierOrders);
              }

              // Enviar WhatsApp al cliente
              if (order.customerPhone) {
                const orderData = {
                  orderNumber: order.orderNumber,
                  customerPhone: order.customerPhone,
                  customerName: `${order.customerFirstName} ${order.customerLastName}`,
                  total: parseFloat(order.total),
                  items: order.items.map(item => ({
                    productName: item.productName,
                    quantity: item.quantity,
                    price: parseFloat(item.price)
                  }))
                };

                await whatsappService.sendOrderConfirmation(orderData);
                await whatsappService.notifyAdminPaymentConfirmed({
                  orderNumber: order.orderNumber,
                  customerName: `${order.customerFirstName} ${order.customerLastName}`,
                  total: parseFloat(order.total),
                  paymentMethod: 'SafetyPay'
                });
              }
            } catch (error) {
              console.error('‚ùå Error procesando √≥rdenes con proveedores:', error);
            }
          }, 500);
        } else {
          console.warn(`‚ö†Ô∏è Orden ${MerchantSalesID} no encontrada`);
        }
      } catch (dbError) {
        console.error('‚ùå Error actualizando orden en BD:', dbError);
      }
    }

    res.status(200).json({
      success: true,
      message: 'Webhook procesado'
    });

  } catch (error) {
    console.error('‚ùå Error procesando webhook:', error.message);

    res.status(500).json({
      success: false,
      message: 'Error al procesar webhook'
    });
  }
});

// GET /api/safetypay/config - Obtener configuraci√≥n p√∫blica
router.get('/config', (req, res) => {
  res.json({
    success: true,
    isConfigured: !!(SAFETYPAY_CONFIG.apiKey && SAFETYPAY_CONFIG.signatureKey),
    isProduction: SAFETYPAY_CONFIG.isProduction
  });
});

module.exports = router;
